Head First Design Patterns

I. Design Patterns
    - Strategy 
        + Encapsulates interchangeable algorithms/behaviours and uses delegation to decide which one to use 
        + Allows the algorithm to vary independently from the clients that use it.
        + Behavioral Software design pattern 
        + Enables selecting an Algorithm at runtime.
        + Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.
    - Observer
        + Defines a one-to-many dependency between objects so that when one object changes state, 
        + All of its dependents are updated and notified automatically
    - Decorator
        + Wraps another object dynamically and provides additional behaviour for it.
        + Provides a flexible alternative to subclassing for extending functionality.
        + Doesn't alter the interface but adds responsibility
    - Factory method
        + Defines an interface for creating an object, but lets subclasses decide which class to instantiate
        + Lets a class defer instantiation to subclasses 
    - Abstract Factory 
        + Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
    - Singleton
        + Ensures a class has only one instance, and provides a global point of access to it. 
    - Command
        + Encapsulates a request as an object, thereby letting you parameterise other objects with different requests,
        queue or log requests, and support undoable operations.
        + Decouples an obect making a request from the one that knows how to perform it.
    - Adapter
        + Wraps an object and provides a different interface to it.
        + Converts the interface of a class into another interface the clients expect.
        + Lets classes work together that couldn't otherwise because of incompatible interfaces.
    - Facade
        + Wraps a bunch of objects to simply their interface
        + Provides a unified interface to a set of interfaces in a subsystem.
        + Defines a higher-level interface that makes the subsystem easier to use.
    - Template Method 
        + Encapsulates algorithms
        + Defines the skeleton (/steps) of an algorithim in a mehtod, deferring some steps to subclasses
        + Subclasses decide how to implement steps in an algorithm (without changing the algorithm's structure)
    - Iterator
        + Provides a way to traverse/access the elements of an aggregate object sequentially without exposing its internal structure.
        + Takes the job iterating over an aggregate and encapsulates it in another object.
    - Composite
        + Provides a structure to hold both individual objects and composite objects.
        + Lets clients treat individual objects and collections/compositions of objects uniformly.
    -