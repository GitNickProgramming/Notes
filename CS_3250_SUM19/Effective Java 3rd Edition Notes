7.1.2019

References:
    - https://github.com/david-sauvage/effective-java-summary 
    
Effective Java 3rd Edition

I. Creating and Destroying Objects 
    - Use Static Factory Methods instead of Constructors
        + Advantages:
            1. Unlike Constructors, they have names
            2. Unlike constructors, they are not required to create a new object each time they are invoked
            3. Unlike constructors, they can return an object of any subtype of their return type
        + Disadvantages:
            1. If providing only static factory methods, classes without public or protect constructors cannot be subclassed
            (encourage to use composition instead inheritance)
            2. They are not readily distinguishable from other static methods 
            (Some common names (each with a different purpose) are: valueOf, of, getInstance, newInstance, getType and newType)
        + Popular Java static factory names 
            ~ valueOf, getInstance, newInstance, getType, ...
        + Constructors do not and one has to differentiate via parameters
        + This can be confusing and lead to errors
        + A class can have only one constructor with a given name 
            ~ Dont change order of constructor parameters to differentiate.
        + Static Factory methods don't have to create a new Object.
            ~ Constructors always do
            ~ Maybe there's an object already created that works
            ~ Helps with immutable classes and pre-constructed instances
        + Singletons, flyweights, non-instantiable
        + Can return a subtype
            ~ Java.util.collections contains all static methds that work on many types 
            ~ Polymorphic
            ~ addAll, binarySearch, disjoint, frequency, min, max, sort, shuffle, reverse, ...
            ~ Type return can be non-public
            ~ Can very implementation.
        + Returned class need not exist at the time the class is written.
            ~ Allows run-time specification
            ~ JDBC an example
        + Service-Provider Framework 
            ~ Service interface 
            ~ Provider registration
            ~ Service Access 
            ~ Optional service provider interface 
                * Factory to create service provider
        + As of Java 6
            ~ General-purpose java.util.ServiceLoader
            ~ So you don't have to write your own.

                public static Boolean valueOf(boolean b) {
                    return b ? Boolean.True : Boolean.False;
                }
    
    - Use Builders when faced with many constructors
        + Is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters.
        + Builders pattern simulates named optional parameters as in ADA and Python
        + If a class has many fields that need initializing, constructors have long list of parameters.
            ~ Constructors often chained/telescoping
        + Create empty instance and have many set()s 
            ~ Problem: Instance in inconsistent state 
        + Builder pattern 
            ~ build() is parameter-less static method 
        + Required parameters passed in the constucotrs
            ~ Optionals set()
            ~ Other languages have optional parameters instead

                public class Elvis{
		            public static final Elvis INSTANCE = new Elvis();
		            private Elvis(){...}
		            ...
		            public void singASong(){...}
	            }

    - Enforce the singleton property with a private constructor or an enum type 
        + Public final field 
        + One problem is that a privileged client can invoke the private constructor reflectively.
        + Against this attack the constructor needs to be modified to send an exception if it is asked to create a second instance. 
        + Singleton with static factory:
            
                public class Elvis{
		            private static final Elvis INSTANCE = new Elvis();
		            private Elvis(){...}
		            public static Elvis getInstance(){ return INSTANCE; }
		            ...
		            public void singASong(){...}
	            }

        + In this approach it can be changed to a non-singleton class without changing the class API
        + Serialize a singleton 
            * It is needed to add a readResolve method and declare all the fields transient in addition to the implements Serializable to
            maintain the singleton guarantee. 

                private Object readResolve(){
		            //Return the one true Elvis and let the garbage collector take care of the Elvis impersonator
		            return INSTANCE;
	            }

        + Enum Singleton, the preferred approach 

                public enum Elvis(){
		            INSTANCE;
		            ...
		            public void singASong(){...}
	            }
        
        + Equivalent to the public field, more concise, provides serialization machinery for free, and guarantee against multiple
        instantiation, even for reflection attacks and sophisticated serialization. It is the best way to implement a singleton 

    - Enforce Non-instantiability with a private constructor 
        + Just have a private no-args constructor 
            ~ If have any no-args constructor, the default isn't created.
        + Class cannot be sub-classed
        + For Classes that group static methods and static fields 
        + Used for example to:
            * Group related methods on primitive values or arrays.
            * Group static methods, including factory methods, for objects that implement a particular interface.
            * Group methods on a final class instead of extending the class.
        + Include a private constructor

                >>>

    - Dependency Injection
        + Helps perserve Immutability
        + Works for constructors, factories, and builders.
        + Can pass factory into constructor 
            ~ Mosaic create (Supplier < ? Extends Tile> tileFactory) {}
        + Use DI frameworks.
        + A common mistake is the use of a singleton or a static utility class for a class that depends on underlying ressources.
        + The use of dependency injection gives us more flexibility, testability and reusability 
        + Example:

                public class spellChecker{
                    private final Lexicon dictionary;
                    public SpellChecker (Lexicon dictionary){
                        this.dictionary = Objects.requireNonNull(dictionary);
                    }
                }

    - Avoid Creating unnecessary Objects
        + Use literals and valueOf()
        + Anything that is immutable 
        + Anything that is stateless
            ~ E.g.: Adapters
        + When possible se the static factory method instead of constructor (Example : Boolean) be vigilant on autoboxing.
        + The use of primitive and his boxed primitive type can be harmful.
        + Most of the time use primitives.

    - Eliminate obsolete object references
        + Memory leaks can happen in: 
            * A class that managed its own Memory
            * Caching objects 
            * The use of listeners and callback 
        + In those three cases the programmer needs to think about nulling object references that are known to be obsolete.
        + Avoid Finalizers and cleaners
        + Try with resources
        + Try very hard to not manae memory 
        + Nulling object references should be very unusual.

    - Avoid Finalizers 
        + Unpredictable, often dangerous, generally unnecessary.
        + Unlike C++ destructors 
            ~ These are called immediately 
            ~ Java uses try/finally for these types of uses.
        + One never knows when a finalizer is called 
            ~ Part of garbage collection 
            ~ Might not be called at all 
        + Don't e.g. close files as there is a limited number of open files.
        + Finalizers are slow 
        + Finalizers are not chained 
        + If really need functionality, provide explicit termination method.
        + There are finalizer attacks 
            ~ Create final finalize method to protect 
        + Implement AutoClosable
            ~ Have to have close method 
            ~ Used with try-with-resources statements
            
II. Methods of the Object class 
    - Equals
        * Sometimes, you don't need to:
            ~ When all object are unique, such as threads.
            ~ When you don't need it, such as with random number generators.
            ~ Superclass equals works well, such as sets, lists, and maps getting from AbstractList, etc.
            ~ Class is private or package private and you know you don't need it.
                + Consider implementing with an assertion.
        * When to Implement 
            ~ When logical equality (.equals) is different from simple object identity (==)
            ~ This is the typical case as classes have state, kept by variables with values.
            ~ Tests for equivalence, not the same object.
            ~ When we need the class to be map keys or set elements.
        * Must implement an Equivalence Relation.
            ~ Must be Reflexive 
            ~ Must be Symmetric 
            ~ Must be transitive 
            ~ Must be consistent 
            ~ For any non-null reference
        * the equals method needs to be overriden when the class has a notion of logical equality.
        * This is generally the case for value classes.
        * The equals method must be:
            ~ Reflexive (x = x) 
            ~ Symmetric (X = y => y = x)
            ~ Transitive (X = y and y = z => x = z)
            ~ Consistent
            ~ For non-null x, x.equals(null) should return False
        * There is no way to extend an instantiable class and add a value while preserving the equals contract.
        * You can safely add values to a subclass of an abstract class.
        * Not respecting those rules will have impact on the use of List, Set, or Map.
    - hashCode
        * The hashCode method needs to be overriden if the equals method is overriden.
        * Here is the contract of the hashCode method:
            ~ hashCode needs to be consistent 
            ~ if a.equals(b) is true then a.hashCode() == b.hashCode()
            ~ if a.equals(b) is false then a.hashCode() doesn't have to be different of b.hashCode()
        * If you don't respect this contract, HashMap or HashSet will behave erratically. 
    - toString
        * Override toString in every instantiable classes unless a superclass already did it. 
        * Most of the time it helps when debugging.
        * It needs to be a full representation of the object
        * Every informations contained in the toString representation should be accessible in some other way in order to avoid
        programmers to parse the String representation.
    - clone
        * When you implement Cloneable, you should ask override clone with a public method whose return type is the class itself.
        * It needs to be a full representation of the object 
        * Every informations contained in the toString representation should be accessible in some other way in order to avoid 
        programmers to parse the String representation.
        * Also, when you need to provide a way to copy classes, you can think first of copy constructor or copy factory except for arrays.
    - Implementing comparable
        * if you have a value class with an obvious natural ordering, you should implement Comparable.
        * Here is the contract of the compareTo method:
            ~ signum(x.compareTo(y)) == -signum(y.compareTo(x))
            ~ x.compareTo(y) > 0 && y.compareTo(z) > 0 => x.compareTo(z) > 0
            ~ x.compareTo(y) == 0 => signum (x.compareTo(z)) == signum(y.compareTo(z))
        * It's also recommended that (x.compareTo(y) == 0) == x.equals(y) 
        * If it's not, it has to be documented that the natural ordering of this class is inconsistent with equals 
        * When confronted to different types of Object, compareTo can throw ClassCastExeception
III. Classes and Interfaces 
    - Accessibility
        * Make accessibility as low as possible.
        * Work on a public API that you want to expose and try not to give access to implementation details
    - Accessor Methods 
        * Public classes should never expose its fields.
        * Doing this will prevent you to change its representation in the future.
        * Package private or private nested classes, can, on the contrary, expose their fields since it won't be part of the API 
    - Immutability 
        * To Create an mmutable class:
            ~ Don't provide methods that modify the visible object's state 
            ~ Ensure that the class can be extended 
            ~ Make all fields final 
            ~ Make all fields private 
            ~ Don't give access to a reference of a mutable object that is a field of your class 
        * As a rule of thumb, try to limit mutability 
    - Favor composition over inheritance 
        * With inheritance, you don't know how your class will react with a new version of its superclass.
        * For example:
            ~ You may have added a new method whose signature will happen to be the same as a method of its superclass in the next release.
            ~ You will then override a method without even knowing it 
        * Also, if there is a flaw in the API of the superclass you will suffer from it too.
        * With composition, you can define your own API for your class 
        * As a rule of thumb:
            ~ To know if you need to choose inheritance over composition, you need to ask yourself if B is reall a subtype of A.
    - Create classes for inheritance or forbit it 
        * First of all, you need to document all the uses of overridable methods.
        * Remember that you'll have to stick to what you documented.
        * The best way to test the design of your class is to try to write subclasses.
        * Never call overridable methods in you constructor 
        * If a class is not designed and documented for inheritance it should be made forbidden to inherit.
            ~ either by making it final, or making its constructors private (or package private) and use static factories. 
    - Interfaces are better than abstract classes 
        * Since Java 8, it's possible to implement default mechanism in an interface.
        * Java only permits single inheritance so you probably won't be able to extends your new abstract class to existing classes
        * When you always will be permitted to implement a new interface.
        * When designing interfaces, you can also provide a Skeletal implementation.
        * This type of implementation is an abstract class that implements the interface.
        * It can help developers to implement your interfaces and since default methods are not permitted to override Object Methods,
        you can do it in your skeletal implementation.
        * Doing both allows developers to use the one that will fit their needs. 
    - Design interfaces for posterity 
        * With Java 8+, it's now pssible to add new methods in interfaces without breaking old implemetations thanks to default methods.
        * Nonetheless, it needs to be done carefully since it can still break old implementations that will fail at runtime.
    - Interfaces are mean't to define types 
        * Interfaces must be used to define types, not to export constants. 
    - Tagged Classes 
        * those kinds of classes are clutted with boilerplate code (Enum, switch, useless field depending on the enum).
        * Don't use them. Create a class hierarchy that will fit your needs better.
    - Nested classes 
        * If a member class does not need access to its enclosing instance then declare it static.
        * If the classs is non-static, each instance will have a reference to its enclosing instance.
            ~ That can result in the enclosing instance not being garbage collected and memory leaks.
    - One single top level class by file
        * Even though it's possible to write multiple top level classes in a single file, don't!
        * Doing so can result in multiple definition for a single class at compile time.
IV. Generics 
    - Raw Types
        * A raw type is a generic type without its type parameter.
        * Example:
            ~ List is the raw type of List<E>
        * Raw types shouldn't be used.
        * They exist for compatibility with older versions of Java.
        * We want to discover mistakes as soon as possible (compile time)
        * Using Raw types will probably result in error during runtime.
        * We still need to use raw types in two cases:
            ~ Usage of class litrals (List.class)
            ~ Usage of instanceof 
    - Unchecked Warnings
        * Working with generics can often create warnings about them.
        * Not having those warnings assure you that your code is typesafe.
            ~ Try as hard as possible to eliminate them.
        * Those warnings represents a potential ClassCastException at runtime.
        * When you prove your code is safe but you can't remove this warning use the annotation @SuppresWarnings("unchecked")
        as close as possible to the declaration.
        * Also, comment on why it is safe.
    - List and Arrays 
        * Arrays are covariant and generics are invariant meaning that object[] is a superclass of String[] when List<Object>
        is not for List<String>.
        * Arrays are reified when generics are erased.
            ~ Meaning that array still have their typing right at runtime when generics don't.
        * In order to assure retrocompatibility with previous version List<String> will be a List at runtime.
        * Typesafety is assured at compile time with generics.
        * Since it's always better to have our coding errors the sooner (meaning at compile time), prefer the usage of generics over arrays.
    - Generic types 
        * Generic types are safer and easier to use because they won't require any cast from the user of this type.
        * When creating new types, always think about generics in order to limit casts. 
    - Generic Methods
        * Like types, methods are safer and easier to use if they are generics.
        * If you don't use generics, your code will require users of your method to cast parameters
            ~ return values which will result in non-typesafe code.
    - Bounded Wildcards 
        * Bounded wildcards are important in order to make our code as generic as possible.
        * They allow more than a simple type but also all their sons (? extends E) or parents (? super E)
    - Generics and varargs 
        * Even though it's not legal to declar generic arrays explicitly, it's still possible to use varargs with generics.
        * This inconsistency has been a choice because of its usefulness (Example: Arrays.asList(T...a))
        * This can, obviously, create problems regarding type safety.
        * To make a generic varargs method safe, be sure:
            ~ It doesn't store anything in the varargs array
            ~ it doesn't make the aray visible to untrusted code when those two coniditions are met.
            ~ Use the annotation @SafeVarargs to remove warnings that you took care of and show users of your methods that it is typesafe.
V. Enums and Annotations 
    - Enums instead of int constants 
        * Prior to enums it was common to use int to represent enum tpes.
        * Doing so is now obsolete and enum tpyes must be used.
        * The usage of int made them difficult to debug (all you saw was int values).
        * Enums are classes that export one instance for each enumeration constant.
        * They are instance controlled.
        * They provide type safety and a way to iterate over each values.
        * If you need a specific behavior for each value of your enum, you can declare an abstract method that you will implement for each value.
        * Enums have an automatically enerated valueOf(String) method that translates a constant's name into the constant.
        * If the toString method is overriden, you should write a fromString method.
    - Instance fields instead of ordinals
        * Never use the ordinal method to calculate a value associated with an enum.
    - EnumSet instead of bit fields 
        * Before enums existed, it was common to use a bit fields for enumerated types that would be used in sets.
        * This would allow you to combine them but have the same issues than int constants were saw in item 34.
            ~ Instead, use EnumSet to combine multiple enums.
    - EnumMap instead of ordinal 
        * You may want to store data by a certain enum.
            ~ For that you could have the idea to use the ordinal method.
            ~ This is a bad practice.
            ~ Instead, prefer the use of EnumMaps.
    - Emulate extensible enums with interfaces
        * The language doesn't allow use to write extensible enums.
        * In the few cases that we would want an enum type to be extensible:
            ~ We can emulate it with an interface written for the basic enum.
        * Users of the api will be able to implement this interface in order to "extend" your enum.
    - Annotations instead of Naming Patterns 
        * Prior to JUnit 4, you needed to name your tests by starting with the word "test". 
        * This is bad practice since the compiler will never complain if:
            ~ by mistake, you've named a few of them "tset". 
        * Annotations are a good way to avoid this kind of naming pattern and gives use more security.
    - Use @Override 
        * You should use the @Override for every method declaration that you believe to override a superclass declaration.
    - Marker interfaces
        * A marker interface is an interface that contains no method declaration
        * It only "marks" a class that implements this interface.
        * One common example is the JDK is Serializable.
        * Using marker interface results in compile type checking.
VI. Lambdas and Streams
    - Lambdas are clearer than anonymous classes
        * Lambdas are the best wat to represent function objects.
        * As a rule of thumb,
            ~ lambdas needs to be short to be readable.
            ~ Three Lines seems to be a reasonable limit.
        * Also, the Almbdas needs to be self-explanatory since it lacks name or documentation.
        * Always think in terms of readability.
    - Method references 
        * Most of the time, method references are shorter and then clearer.
        * The more arguments the lambdas has, the more the method reference will be clearer.
        * When a lmbda is too long, you can refactor it to a method
            ~ Which will give a name and documentation)
        * Use it as a method reference.
        * There are five kinds of method references:
            ~ Method Ref Type 
                1. Static
                    Example: Integer::parseInt
                    Lambda Equivalent -->  str -> Integer.parseInt(Str) 
                2. Bound 
                    Example: Instant.now()::isAfter
                    Lambda Equivalent -->  Instant then = Instant.now(); t -> then.isAfter(t) 
                3. Unbound
                    Example: String::toLowerCase
                    Lambda Equivalent -->  str -> str.toLowerCase() 
                4. Class Constructor 
                    Example: TreeMap<k,v>::new 
                    Lambda Equivalent -->  () -> new TreeMap<k,v>
                5. Array Constructor
                    Example: int[]::new 
                    Lambda Equivalent -->  len -> new int[len] 
    - Standard Functional interfaces 
        * java.util.Function provides a lot of functional interfaces.
        * If one of those does the job, you should use it.
        * Here are more common interfaces:
            ~ Interface
                1. UnaryOperator
                    Function Signature: T apply (T t) 
                    Example: String::toLowerCase 
                2. BinaryOperator 
                    Function Signature: T apply(T t1, T t2)
                    Example: BigInterger::add 
                3. Predicate
                    Function Signature: boolean test(T t) 
                    Example: Collection::isEmpty 
                4. Function<T, R>
                    Functional Signature: R apply(T t)
                    Example: Arrays::asList 
                5. Supplier
                    Functional Signature: T get() 
                    Example: Instant::now 
                6. Consumer
                    Functional Signature: void accept(T t)
                    Example: System.out::println 
        * When creating your functional interfaces, always annotate with @FunctionalInterfaces so that it won't compile unless it 
        has exactly one abstract method.
    - Streams
        * Carefully name parameters of lambda in order to make your stream pipelines readable.
        * Also, use helper methods for the same purpose.
        * Streams should mostly be used for tasks like:
            ~ Transform a sequence of elements
            ~ Filter a sequence of elements 
            ~ Combine sequence of elements 
            ~ Accumulate a sequence of elements inside a collection (perhaps grouping them)
            ~ Search for an element inside of a sequence 
    - Prefer side-effect-free functions in streams 
        * Programming with streams pipelines should be side effect free.
        * The terminal forEach method should only be used to report the result of a compuation not to perform the computation itself.
        * In order to use streams properly, you need to know about collectors.
            ~ The most important ones are:
                1. toSet
                2. toMap 
                3. groupingBy
                4. joining
    - Return collections instead of streams 
        * The collection interface is a subtype of Iterable and has a stream method.
        * It provides bother iteration and stream access.
        * If the collection in too big memory wise, return what seems more natural (stream or iterable)
    - Parallelization 
        * Parallelizing a pipeline is unliekly to increase its performance if it comes from a Stream.iterate or limit method is used.
        * As a rule of thumb,
            ~ Parallelization should be used on ArrayList, HashMap, HashSet, ConcurrentHashMap, arrays, int ranges and double ranges.
            ~ Those structures can be divided in any desired subranged and so on, easy to work among parrallel threads.
VII. Methods
    - Check parameters for validity
        * When writing a public or protected method, you should begin by checking that the parameters are not enforcing the 
            restrictions that you set.
        * You should also document what kind of exception you will throw if a parameter enforcing those restrictions.
        * The Objects.requireNonNull method should be used for nullability checks 
    - Defensive copies 
        * If a class has mutable components that comes from or goes to the client, the class needs to make defensive copies of those
        components.
    - Method Signature
        * Few Rules to follow when designing your API:
            ~ Choose your method name carefully. Be explicit and consistent.
            ~ Don't provide too many convenience methods. A small API is easier to learn and use.
            ~ Avoid Long parameter lists.
            ~ Use Helper Class if Necessary
            ~ Favor interfaces over classes for parameter types.
            ~ Prefer enum types to boolean parameters when it makes the parameter more explicit.
    - Overloading
        * It is recommanded to never export two overloadings with the same number of parameters.
        * If you have to, consider giving different names to your methods. (writeInt, writeLong)
    - Varargs 
        * Varargs are great when you need to define a method with a variable number of arguments.
        * Always precede the varargs parameter with any required parameters.
    - Return emply collections or arrays instead of null 
        * Returning null when you don't have elements to return makes the use of your methods more difficult.
        * Your client will have to check if your object is not null.
        * Instead always return an empty array of collection.
    - Return of Optionals 
        * You should declare a method to return Optional if it might not be able to return a result and clients will have to perform special processing
        if no result is returned.
        * You should never use an optional of a boxed primitive.
        * Instead, use OptionalInt, OptionalLong, etc...
    - Documentation
        * Documenations should be mandatory for exported API.
VIII. General Programming 
    - Minimize the scope of local variables
        * To limit the scope of your variables, you should:
            ~ Declare them when first used 
            ~ Use for loops instead of while when doable
            ~ Keep your methods small and focused 
    - For each loops instead of traditional loops 
        * the default for loop must be a for each loop.
        * It's more readable and can avoid you some mistakes.
        * Unfortunately, There are situations where you can't use this kind of loop:
            ~ When you need to delete some elements.
            ~ When you need to replace some elements.
            ~ When you need to traverse multiple collections in parallel.
    - Use the standard libraries 
        * When usig a standard library you take advantage of the knowledge of experts and the experience of everyone who used it before you.
        * Don't reinvent the wheel!!!
        * Library code is probably better than code that we would write simply because this code receives more attention than we could afford.
    - Avoid fload and double for exact answers
        * Fload and double types are not suited for monetary calculations. 
        * Use BigDecimal, int or long for this kind of calculation.
    - Prefer primitives to boxed primitives
        * Use primitives whenever you can. The use of boxed Primitives is essentially for type parameters in parameterized types
        * Example:
            ~ Keys and values in collections 
    - Avoid Strings when other types are more appropriate
        * A void natural tendency to represent objects as Strings when there is a better data types available.
    - String Concatenation
        * Don't use the String concatenation operator to combine more than a few Strings.
        * Instead,
            ~ Use a StringBuilder
    - Refer to objects by their interfaces 
        * If an interface exists, parameters, return values, variables and fields should be declared using this interface to insure flexibility.
        * If there is no appropriate interface, use the least specific class that provides the functionality you need.
    - Prefer interfaces to reflection 
        * Reflextion is a powerful tool but has many disadvantages.
        * When you need to work with classes unknown at compile time, try to only use it to instantiate object and then access them by using an interface of superclass
        known at compile time.
    - Native methods
        * It's really rare that you will need to use native methods to improve performaces.
        * If it's need to access native libraries use as little native code as possible.
    - Optimization
        * Write good programs rather than fast one.
        * Good Programs localize design decisions within individual components so those individuals decisions can be changed easily if performance becomes an issue.
        * Good design decisons will give you good performances.
        * Measure performances before and after each attempted optimization.
    - Naming conventions
        * Package 
            ~ org.junit.jupiter, com.google.common.collect 
        * Class or interface 
            ~ Stream, FutureTaskm LinkedHashMap, HttpServlet
        * Method or Field 
            ~ remove, groupBy, getCrc 
        * Constant field 
            ~ MIN_VALUE, NEGATIVE_INFINITY
        * Local Variable 
            ~ i, denom, houseNum
        * Type Parameter 
            ~ T, E, K, V, X, R, U, V, T1, T2 
IX. Exceptions
    - Exceptions are for exceptional conditions 
        * Exceptions should never be used for ordinary control flow.
        * They are designed for exceptional conditions and should be used accordingly
    - Checked exceptions and runtime exceptions 
        * Use checked exceptions for conditions from which the caller can reasonably recover.
        * Use runtime exceptions to indicate programming errors.
        * By Convention:
            ~ Errors are only used by the JVM to indicate conditions that make execution impossible.
            ~ Therefore, all the unchecked throwables you implement must be a subclass of RuntimeException.
    - Avoid unnecessary use of checked exceptions 
        * When used sparingly, check exceptions increase the reliability of programs.
        * When overused, they make APIs painful to use.
        * Use checked exceptons only when you want the callers to handle the exceptional condition.
        * Remember that a method that throws a checked exception can't be used directly in streams.
    - Standard exceptions 
        * When appropriate, use the exceptions provided by the JDK. Here's a list of the most common exceptions:
            ~ IllegalArgumentException
                Non-null parameter value is inappropriate
            ~ IllegalStateException
                Object state is inappropriate for method invocation
            ~ NullPointerException
                Parameter value is null where prohibited
            ~ IndexOutOfBoundsException
                Index parameter value is out of range 
            ~ ConcurrentModificationException 
                Concurrent modification of an object has been detected where it is prohibited
            ~ UnsupportedOperationException 
                Object does not support method 
    - Throw exceptions that are appropriate to the abstraction
        * Higher layers should catch lower level exceptions and throw exceptions that can be explained at their level of abstraction 
        * While doing so, don't forget to use chaining in order to provide the underlying cause for failure.
    - Document throw exceptions 
        * Document every exceptions that can be thrown by your methods, checked or unchecked.
        * This documentation should be done by using the @Throws tag.
        * Nonetheless, only checked exceptions must be declared as thrown in your code.
    - Include failure capture information in detail messages 
        * The detailed message of an exception should contain the values of all parameters that lead to such failure.
    - Failure atomicity 
        * A fialed method invocation should leave the object in the state that it was before the invocation.
    - Don't ignore exceptions 
        * An empty catch block defeats the purpose of exception which is to force you to handle ecveptional conditions.
        * When you decide with very good reasons to ignore an exception the catch block sould contain a comment explaining those reasons
        and the variable should be named ignored.
X. Concurrency 
    - Synchronize access to shared mutable data 
        * Synchronization is not guaranteed to work unless both read and write operations are synchronized.
        * When multiple threads share mutable data, each of them that reads or writes this data must perform synchronization.
    - Avoid excessive synchronization 
        * As a rule, you should do as litle work as possible inside synchronized regions.
        * When designing a mutable class think about whether or not it should be synchronized.
    - Executors, tasks and streams 
        * The java.util.concurrent package added the executor framework.
        * It contains class such as ExecutorService that can help you run Tasks in other threads.
        * You should refrain from using Threads and now using this framework in order to parallelize computation when needed.
    - Prefer concurrency utilities to wait and notify
        * Using wait and notify is quite difficult.
        * You should then use the higher level concurrency utilities such as the Executor Framework, concurrent collections and synchronizers.
            ~ Common concurrent collections : ConcurrenthashMap, BlockingQueue
            ~ Common synchronizers : Countdownlatch, Semaphore
    - Document thread safety 
        * Every class should document its thread safety.
        * When writing an unconditionnally tread safe class, consider using a private lock object instead of synchronized methods.
        * This will give you more flexibility.
    - Lazy initialization
        * In the context of concurrency, lazy initialization is tricky.
        * Therefore, normal initialization is preferable to lazy initialization.
        * On a static field you can use the lazy initialization holder class idiom
        * On an instance field you can use the double-check idiom 
    - Don't depend on the thread scheduler
        * The best way to write a robust and responsive program is to ensure that the average number of runnable threads is not significantly
        greater than the number of procesors.
        * Thread prioriteis are among the least portable features of java
XI. Serialization 
    - Prefer alternatives to Java serialization 
        * Serialization is dangerous and should be avoided.
        * Alernatives such as JSON should be used.
        * If working with Serialization, try not to deserialize untrusted data.
        * If you have no other choice, use object deserialization filtering.
    - Implement Serializable with great caution
        * Unless a class will only be used in a protected environment where versions will never have to interoperate and servers will never be exposed to untrusted data
        * Implementing Serializable should be decided with great care.
    - Custom Serialized Form 
        * Use the default serialized form only if it's a reasonable description of the logical state of the object.
        * Otherwise, write your own implementation in order to only have its logical state.
    - Write readObject methods defensively
        * When writing a readObject method, keep in mind that you are writing a public constructor and it must produce a valid instance regardless of the stream it is given.
    - For instance control, prefer enum types to readResolve 
        * When you need instance control (such a Singleton) use enum types whenever possible 
    - Serialization proxies
        * The serialization proxy pattern is probably the easiest way to robustly serialize objects if those objects can't be extendable or does not contain circlarities.

